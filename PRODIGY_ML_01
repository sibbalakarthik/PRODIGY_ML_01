import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import warnings
warnings.filterwarnings('ignore')

# Set style for better plots
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")

class HousePricePredictor:
    def __init__(self):
        self.model = LinearRegression()
        self.is_trained = False
        self.feature_names = ['sqft', 'bedrooms', 'bathrooms']
        
    def generate_synthetic_data(self, n_samples=1000):
        """Generate synthetic house data with realistic relationships"""
        np.random.seed(42)  # For reproducibility
        
        # Generate features
        sqft = np.random.normal(2000, 600, n_samples)
        sqft = np.clip(sqft, 800, 5000)  # Realistic range
        
        bedrooms = np.random.choice([2, 3, 4, 5], n_samples, p=[0.2, 0.4, 0.3, 0.1])
        bathrooms = np.random.choice([1, 2, 3, 4], n_samples, p=[0.1, 0.5, 0.3, 0.1])
        
        # Generate prices with realistic relationships + noise
        base_price = (
            sqft * 150 +                    # $150 per sqft
            bedrooms * 20000 +              # $20k per bedroom
            bathrooms * 15000 +             # $15k per bathroom
            50000                           # Base price
        )
        
        # Add noise (¬±20% variation)
        noise = np.random.normal(0, base_price * 0.1, n_samples)
        prices = base_price + noise
        prices = np.clip(prices, 100000, 2000000)  # Realistic price range
        
        # Create DataFrame
        data = pd.DataFrame({
            'sqft': sqft.astype(int),
            'bedrooms': bedrooms,
            'bathrooms': bathrooms,
            'price': prices.astype(int)
        })
        
        return data
    
    def train_model(self, data):
        """Train the linear regression model"""
        X = data[self.feature_names]
        y = data['price']
        
        # Split data
        self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(
            X, y, test_size=0.2, random_state=42
        )
        
        # Train model
        self.model.fit(self.X_train, self.y_train)
        self.is_trained = True
        
        # Store training data for analysis
        self.train_data = data
        
        print("Model trained successfully!")
        print(f"Training samples: {len(self.X_train)}")
        print(f"Test samples: {len(self.X_test)}")
    
    def evaluate_model(self):
        """Evaluate model performance"""
        if not self.is_trained:
            print("Model not trained yet!")
            return
        
        # Predictions
        train_pred = self.model.predict(self.X_train)
        test_pred = self.model.predict(self.X_test)
        
        # Metrics
        train_r2 = r2_score(self.y_train, train_pred)
        test_r2 = r2_score(self.y_test, test_pred)
        train_rmse = np.sqrt(mean_squared_error(self.y_train, train_pred))
        test_rmse = np.sqrt(mean_squared_error(self.y_test, test_pred))
        train_mae = mean_absolute_error(self.y_train, train_pred)
        test_mae = mean_absolute_error(self.y_test, test_pred)
        
        print("\n" + "="*50)
        print("MODEL EVALUATION RESULTS")
        print("="*50)
        print(f"Training R¬≤: {train_r2:.4f}")
        print(f"Test R¬≤: {test_r2:.4f}")
        print(f"Training RMSE: ${train_rmse:,.0f}")
        print(f"Test RMSE: ${test_rmse:,.0f}")
        print(f"Training MAE: ${train_mae:,.0f}")
        print(f"Test MAE: ${test_mae:,.0f}")
        
        # Model coefficients
        print("\nMODEL COEFFICIENTS:")
        print(f"Intercept: ${self.model.intercept_:,.0f}")
        for feature, coef in zip(self.feature_names, self.model.coef_):
            print(f"{feature.capitalize()}: ${coef:,.0f}")
        
        return {
            'train_r2': train_r2, 'test_r2': test_r2,
            'train_rmse': train_rmse, 'test_rmse': test_rmse,
            'train_mae': train_mae, 'test_mae': test_mae
        }
    
    def predict_price(self, sqft, bedrooms, bathrooms):
        """Predict price for a single house"""
        if not self.is_trained:
            print("Model not trained yet!")
            return None
        
        features = np.array([[sqft, bedrooms, bathrooms]])
        predicted_price = self.model.predict(features)[0]
        
        print(f"\nPREDICTION:")
        print(f"House: {sqft} sqft, {bedrooms} bed, {bathrooms} bath")
        print(f"Predicted Price: ${predicted_price:,.0f}")
        
        return predicted_price
    
    def plot_results(self):
        """Create comprehensive visualizations"""
        if not self.is_trained:
            print("Model not trained yet!")
            return
        
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        fig.suptitle('House Price Prediction Model Analysis', fontsize=16, fontweight='bold')
        
        # 1. Actual vs Predicted
        test_pred = self.model.predict(self.X_test)
        axes[0, 0].scatter(self.y_test, test_pred, alpha=0.6, color='blue')
        axes[0, 0].plot([self.y_test.min(), self.y_test.max()], 
                       [self.y_test.min(), self.y_test.max()], 'r--', lw=2)
        axes[0, 0].set_xlabel('Actual Price')
        axes[0, 0].set_ylabel('Predicted Price')
        axes[0, 0].set_title('Actual vs Predicted Prices')
        axes[0, 0].ticklabel_format(style='plain', axis='both')
        
        # 2. Residuals plot
        residuals = self.y_test - test_pred
        axes[0, 1].scatter(test_pred, residuals, alpha=0.6, color='green')
        axes[0, 1].axhline(y=0, color='r', linestyle='--')
        axes[0, 1].set_xlabel('Predicted Price')
        axes[0, 1].set_ylabel('Residuals')
        axes[0, 1].set_title('Residuals Plot')
        axes[0, 1].ticklabel_format(style='plain', axis='both')
        
        # 3. Feature importance (coefficients)
        feature_importance = pd.DataFrame({
            'Feature': self.feature_names,
            'Coefficient': self.model.coef_
        })
        axes[1, 0].bar(feature_importance['Feature'], feature_importance['Coefficient'])
        axes[1, 0].set_title('Feature Coefficients')
        axes[1, 0].set_ylabel('Coefficient Value')
        axes[1, 0].tick_params(axis='x', rotation=45)
        
        # 4. Price distribution
        axes[1, 1].hist(self.train_data['price'], bins=30, alpha=0.7, color='purple')
        axes[1, 1].set_xlabel('Price')
        axes[1, 1].set_ylabel('Frequency')
        axes[1, 1].set_title('Price Distribution')
        axes[1, 1].ticklabel_format(style='plain', axis='x')
        
        plt.tight_layout()
        plt.show()
        
    def correlation_analysis(self):
        """Analyze correlations between features and price"""
        if not self.is_trained:
            print("Model not trained yet!")
            return
        
        # Correlation matrix
        correlation_matrix = self.train_data.corr()
        
        plt.figure(figsize=(10, 8))
        sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0,
                   square=True, linewidths=0.5)
        plt.title('Feature Correlation Matrix')
        plt.tight_layout()
        plt.show()
        
        print("\nCORRELATION WITH PRICE:")
        price_correlations = correlation_matrix['price'].sort_values(ascending=False)
        for feature, corr in price_correlations.items():
            if feature != 'price':
                print(f"{feature.capitalize()}: {corr:.3f}")

def main():
    """Main execution function"""
    print("üè† HOUSE PRICE PREDICTION MODEL")
    print("="*50)
    
    # Initialize predictor
    predictor = HousePricePredictor()
    
    # Generate and display sample data
    print("Generating synthetic house data...")
    data = predictor.generate_synthetic_data(n_samples=1000)
    
    print(f"\nDataset Info:")
    print(f"Total houses: {len(data)}")
    print(f"Price range: ${data['price'].min():,} - ${data['price'].max():,}")
    print(f"Sqft range: {data['sqft'].min()} - {data['sqft'].max()}")
    
    print("\nFirst 5 houses:")
    print(data.head())
    
    print("\nDataset Statistics:")
    print(data.describe())
    
    # Train model
    print(f"\nTraining linear regression model...")
    predictor.train_model(data)
    
    # Evaluate model
    metrics = predictor.evaluate_model()
    
    # Make sample predictions
    print("\n" + "="*50)
    print("SAMPLE PREDICTIONS")
    print("="*50)
    
    sample_houses = [
        (1500, 3, 2),   # Small family home
        (2500, 4, 3),   # Large family home  
        (1200, 2, 1),   # Starter home
        (3500, 5, 4),   # Luxury home
    ]
    
    for sqft, bed, bath in sample_houses:
        predictor.predict_price(sqft, bed, bath)
    
    # Visualizations
    print(f"\nGenerating visualizations...")
    predictor.plot_results()
    predictor.correlation_analysis()
    
    # Interactive prediction function
    def interactive_prediction():
        """Allow user to input custom house features"""
        print("\n" + "="*50)
        print("INTERACTIVE PREDICTION")
        print("="*50)
        
        try:
            sqft = int(input("Enter square footage: "))
            bedrooms = int(input("Enter number of bedrooms: "))
            bathrooms = int(input("Enter number of bathrooms: "))
            
            predicted_price = predictor.predict_price(sqft, bedrooms, bathrooms)
            
            # Confidence interval (rough estimate)
            test_pred = predictor.model.predict(predictor.X_test)
            rmse = np.sqrt(mean_squared_error(predictor.y_test, test_pred))
            
            print(f"Confidence interval (¬±1 RMSE): ${predicted_price-rmse:,.0f} - ${predicted_price+rmse:,.0f}")
            
        except ValueError:
            print("Please enter valid numbers!")
        except KeyboardInterrupt:
            print("\nExiting...")
    
    # Uncomment the line below to enable interactive predictions
    # interactive_prediction()
    
    return predictor, data, metrics

# Example usage
if __name__ == "__main__":
    predictor, data, metrics = main()
    
    # Additional analysis
    print(f"\n" + "="*50)
    print("ADDITIONAL INSIGHTS")
    print("="*50)
    
    # Price per sqft analysis
    data['price_per_sqft'] = data['price'] / data['sqft']
    print(f"Average price per sqft: ${data['price_per_sqft'].mean():.2f}")
    print(f"Price per sqft range: ${data['price_per_sqft'].min():.2f} - ${data['price_per_sqft'].max():.2f}")
    
    # Feature importance interpretation
    print(f"\nFeature Impact on Price:")
    print(f"‚Ä¢ Each additional sqft adds: ${predictor.model.coef_[0]:.2f}")
    print(f"‚Ä¢ Each additional bedroom adds: ${predictor.model.coef_[1]:,.0f}")
    print(f"‚Ä¢ Each additional bathroom adds: ${predictor.model.coef_[2]:,.0f}")
    
    print(f"\nModel Equation:")
    print(f"Price = {predictor.model.intercept_:,.0f} + {predictor.model.coef_[0]:.2f}√ósqft + {predictor.model.coef_[1]:,.0f}√óbedrooms + {predictor.model.coef_[2]:,.0f}√óbathrooms")
